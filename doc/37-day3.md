**Day 3**

[_I dropped my daughter off at the station today and started late so it's a small increment today._]

This [challenge](https://adventofcode.com/2021/day/3) involves processing collections of 1s and 0s.

We have a number of lines (which we can think of as rows) and each line is of the same length. The lines contain a number of binary digits ("bits"), 1s and 0s, which we can think of as columns. Here is some example data.

```
00100
11110
10110
10101
```

The first part of the challenge is to scan each column and produce a a result for each column which is the most frequent bit. This resulting value, called the `gamma rate` is then converted to a number.

Then there is another value called the `epsilon rate` which represents the least common bit in that column.

The problem statement doesn't say what we should do if a column has the same number of 1s and 0s, so let's assume that won't happen.

For a row of width 5, it looks like: 

`gamma_rate + episolon_rate = 2^5 - 1`

or

`epsilon_rate xor 11111 = gamma_rate`

So how should we represent this? I'm inclined to parse the bits into a vector of rows, each of which contains a vector of columns.

Then when processing the data scan each row and add to the `1` and `0` count for each column. The accumulated values could be returned in a Vector of two-element arrays. Arrays are good because they are 0-indexed so the 0 bit count can be in the first element, and the 1 bit count is in the second.

Let's create the template for this, and start with the domain function first, starting with a failing test.

`day3.rs`

```
fn count_column_bits(rows: Vec<Vec<u8>>) -> Vec<[u32; 2]> {
    Vec::new()
}

#[cfg(test)]
mod day3_tests {
    use super::*;

    #[test]
    fn test_count_bits() {
        let rows: Vec<Vec<u8>> = vec!(
            vec!(0, 0, 1, 0, 0),
            vec!(1, 1, 1, 1, 0),
            vec!(1, 0, 1, 1, 0),
            vec!(1, 0, 1, 0, 0));
        let expected = vec!([1,3], [3, 1], [2, 2], [4, 0]);
        assert_eq!(count_column_bits(rows), expected);
    }
}
```

Here's the output from `cargo test day3_tests`

```
---- day3_tests::test_count_bits stdout ----
thread 'day3_tests::test_count_bits' panicked at 'assertion failed: `(left == right)`
  left: `[]`,
 right: `[[1, 3], [3, 1], [2, 2], [4, 0]]`', src/day3.rs:17:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    day3_tests::test_count_bits

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

The failing tests gives us our obvious next thing to tackle.

The input is represented as a vector of vectors of 8-bit integers. And our counting function returns a vector of two-element arrays containing the counts of 0's and 1's in the 0-th and 1st array elements respectively. I selected a 32-bit unsigned integer for the count which should be big enough.

I also added the day3 file details to `Cargo.toml`

```
[[bin]]
name = "day3"
path = "src/day3.rs"
```

Incidentally, here are the relevant files in our directory structure so far.

```
.
├── Cargo.toml
├── input
│   ├── day1.txt
│   └── day2.txt
└── src
    ├── day1.rs
    ├── day2.rs
    ├── day3.rs
    └── main.rs
```

@Beaver




